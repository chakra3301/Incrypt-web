<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@300&display=swap" rel="stylesheet">
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="./assets/favicon.png" />
  <link rel="shortcut icon" type="image/png" href="./assets/favicon.png" />
  
  <!-- Open Graph Meta Tags for Social Media Preview -->
  <meta property="og:title" content="Incrypt Encoder - Hide Messages in Images" />
  <meta property="og:description" content="Upload an image and hide secret messages using LSB steganography. Client-side processing ensures your data never leaves your device." />
  <meta property="og:image" content="./assets/preview.png" />
  <meta property="og:url" content="" />
  <meta property="og:type" content="website" />
  
  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Incrypt Encoder - Hide Messages in Images" />
  <meta name="twitter:description" content="Upload an image and hide secret messages using LSB steganography. Client-side processing ensures your data never leaves your device." />
  <meta name="twitter:image" content="./assets/preview.png" />
  
  <link rel="stylesheet" href="./styles/style.css" />
  
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: 'Orbitron', monospace;
      font-weight: 300;
      text-align: center;
      padding: 2rem;
      margin: 0;
      overflow-x: hidden;
    }
    
    /* Responsive padding for body */
    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding: 0.5rem;
      }
    }
    
    .header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      background: #11111145;
      z-index: 1000;
      box-sizing: border-box;
    }
    
    /* Responsive header */
    @media (max-width: 768px) {
      .header {
        padding: 8px 15px;
        background: #111;
      }
    }
    
    @media (max-width: 480px) {
      .header {
        padding: 5px 10px;
        flex-direction: column;
        gap: 10px;
        background: #111;
      }
    }
    
    .header-logo {
      height: 50px;
      margin-right: auto;
      filter: brightness(150%);
    }
    
    /* Responsive logo */
    @media (max-width: 768px) {
      .header-logo {
        height: 40px;
      }
    }
    
    @media (max-width: 480px) {
      .header-logo {
        height: 35px;
        margin-right: 0;
      }
    }
    
    .header-nav {
      display: flex;
      flex: 1;
      justify-content: center;
      gap: 50px;
    }
    
    /* Responsive navigation */
    @media (max-width: 768px) {
      .header-nav {
        gap: 30px;
        justify-content: center;
      }
    }
    
    @media (max-width: 480px) {
      .header-nav {
        gap: 20px;
        justify-content: center;
        width: 100%;
      }
    }
    
    .nav-button {
      font-family: 'Orbitron', monospace;
      font-weight: 300;
      color: white;
      text-decoration: none;
      padding: 10px 15px;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }
    
    /* Responsive nav buttons */
    @media (max-width: 768px) {
      .nav-button {
        padding: 12px 12px;
        font-size: 14px;
      }
    }
    
    @media (max-width: 480px) {
      .nav-button {
        padding: 10px 10px;
        font-size: 12px;
      }
    }
    
    .nav-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    #matrixCanvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }
    
    /* Hide matrix on mobile devices */
    @media (max-width: 768px) {
      #matrixCanvas {
        display: none;
      }
    }
    
    canvas {
      border: 1px solid #555;
      margin-top: 0.5rem;
      max-width: 100%;
      height: auto;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    
    /* Responsive canvas */
    @media (max-width: 768px) {
      canvas {
        width: 100%;
        max-width: 400px;
        height: auto;
      }
    }
    
    @media (max-width: 480px) {
      canvas {
        max-width: 300px;
      }
    }
    
    input, textarea, button, label {
      margin: 0.5rem;
      padding: 0.5rem;
      z-index: 3;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    /* Responsive form elements */
    @media (max-width: 768px) {
      input, textarea, button, label {
        margin: 0.3rem;
        padding: 0.4rem;
        font-size: 14px;
      }
    }
    
    @media (max-width: 480px) {
      input, textarea, button, label {
        margin: 0.2rem;
        padding: 0.3rem;
        font-size: 12px;
      }
    }
    
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      max-width: 100%;
      padding: 0 1rem;
    }
    
    /* Responsive controls */
    @media (max-width: 768px) {
      .controls {
        gap: 0.8rem;
        padding: 0 0.5rem;
      }
    }
    
    @media (max-width: 480px) {
      .controls {
        gap: 0.6rem;
        padding: 0 0.3rem;
      }
    }
    
    .slider-group {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    /* Responsive slider groups */
    @media (max-width: 768px) {
      .slider-group {
        gap: 0.8rem;
        flex-direction: column;
        align-items: center;
      }
    }
    
    @media (max-width: 480px) {
      .slider-group {
        gap: 0.5rem;
      }
    }
    
    .title-image {
      max-width: 30%;
      height: auto;
      margin: -100px;
      z-index: 0;
      filter: drop-shadow(0 0 8px rgba(0, 255, 0, 0.3));
      transition: all 0.3s ease;
    }
    
    /* Responsive title image */
    @media (max-width: 768px) {
      .title-image {
        max-width: 50%;
        margin: -50px;
      }
    }
    
    @media (max-width: 480px) {
      .title-image {
        max-width: 70%;
        margin: 50px;
      }
    }
    
    .title-image:hover {
      filter: drop-shadow(0 0 12px rgba(0, 255, 0, 0.5));
      transform: scale(1.02);
    }
    
    .advanced-menu {
      display: none;
      background: rgba(0, 0, 0, 0.8);
      padding: 1rem;
      border-radius: 8px;
      margin: 1rem 0;
      border: 1px solid rgba(188, 189, 188, 0.3);
      width: 100%;
      max-width: 600px;
      box-sizing: border-box;
    }
    
    /* Responsive advanced menu */
    @media (max-width: 768px) {
      .advanced-menu {
        padding: 0.8rem;
        margin: 0.8rem 0;
      }
    }
    
    @media (max-width: 480px) {
      .advanced-menu {
        padding: 0.6rem;
        margin: 0.6rem 0;
      }
    }
    
    .advanced-menu.show {
      display: block;
    }
    
    .advanced-toggle {
      background: rgba(194, 194, 194, 0.1);
      border: 1px solid rgba(156, 156, 156, 0.3);
      color: rgb(188, 188, 188);
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
    }
    
    /* Responsive advanced toggle */
    @media (max-width: 768px) {
      .advanced-toggle {
        padding: 0.4rem 0.8rem;
        font-size: 14px;
      }
    }
    
    @media (max-width: 480px) {
      .advanced-toggle {
        padding: 0.3rem 0.6rem;
        font-size: 12px;
      }
    }
    
    .advanced-toggle:hover {
      background: rgba(189, 189, 189, 0.2);
    }
    
    .action-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin: 1rem 0;
      flex-wrap: wrap;
    }
    
    /* Responsive action buttons */
    @media (max-width: 768px) {
      .action-buttons {
        gap: 0.8rem;
        margin: 0.8rem 0;
      }
    }
    
    @media (max-width: 480px) {
      .action-buttons {
        gap: 0.6rem;
        margin: 0.6rem 0;
        flex-direction: column;
        align-items: center;
      }
    }
    
    .action-button {
      background: rgba(188, 188, 188, 0.1);
      border: 1px solid rgba(188, 188, 188, 0.3);
      color: rgb(188, 188, 188);
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
    }
    
    /* Responsive action buttons */
    @media (max-width: 768px) {
      .action-button {
        padding: 0.4rem 0.8rem;
        font-size: 14px;
      }
    }
    
    @media (max-width: 480px) {
      .action-button {
        padding: 0.3rem 0.6rem;
        font-size: 12px;
        width: 100%;
        max-width: 200px;
      }
    }
    
    .action-button:hover {
      background: rgba(187, 187, 187, 0.2);
    }
    
    .output-box {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      display: none;
    }
    
    .output-box.show {
      display: block;
    }
    
    /* Share section styles */
    .share-section {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(188, 188, 188, 0.1);
      border: 1px solid rgba(188, 188, 188, 0.3);
      border-radius: 8px;
      display: none;
    }
    
    .share-section.show {
      display: block;
    }
    
    .share-description {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.05);
      color: #eee;
      font-family: 'Orbitron', monospace;
      font-weight: 300;
      resize: vertical;
      min-height: 60px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
    
    .share-description:focus {
      outline: none;
      border-color: rgba(188, 188, 188, 0.5);
      box-shadow: 0 0 10px rgba(188, 188, 188, 0.2);
    }
    
    .share-button {
      background: rgba(188, 188, 188, 0.1);
      border: 1px solid rgba(188, 188, 188, 0.3);
      color: rgb(188, 188, 188);
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      font-family: 'Orbitron', monospace;
      font-weight: 300;
      border-radius: 5px;
    }
    
    .share-button:hover {
      background: rgba(187, 187, 187, 0.2);
    }
    
    .share-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Responsive output box */
    @media (max-width: 768px) {
      .output-box {
        padding: 0.8rem;
        margin: 0.8rem 0;
      }
    }
    
    @media (max-width: 480px) {
      .output-box {
        padding: 0.6rem;
        margin: 0.6rem 0;
        font-size: 12px;
      }
    }
    
    /* Responsive textarea */
    textarea {
      resize: vertical;
      min-height: 80px;
    }
    
    @media (max-width: 768px) {
      textarea {
        min-height: 60px;
        max-width: 90%;
      }
    }
    
    @media (max-width: 480px) {
      textarea {
        min-height: 50px;
        max-width: 95%;
      }
    }
    
    /* Responsive file input */
    input[type="file"] {
      max-width: 90%;
    }
    
    .file-input-container {
      position: relative;
      display: inline-block;
      cursor: pointer;
      margin-bottom: 10px;
    }
    
    .file-input-label {
      background: rgba(188, 188, 188, 0.1);
      border: 1px solid rgba(188, 188, 188, 0.3);
      color: rgb(188, 188, 188);
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      text-align: center;
      font-size: 14px;
      font-family: 'Orbitron', monospace;
      font-weight: 300;
      border-radius: 5px;
    }
    
    .file-input-label:hover {
      background: rgba(187, 187, 187, 0.2);
    }
    
    /* Responsive file input label */
    @media (max-width: 768px) {
      .file-input-label {
        padding: 0.4rem 0.8rem;
        font-size: 14px;
      }
    }
    
    @media (max-width: 480px) {
      .file-input-label {
        padding: 0.3rem 0.6rem;
        font-size: 12px;
        width: 100%;
        max-width: 200px;
      }
    }
    
    /* Responsive range inputs */
    input[type="range"] {
      min-width: 150px;
    }
    
    @media (max-width: 768px) {
      input[type="range"] {
        min-width: 120px;
      }
    }
    
    @media (max-width: 480px) {
      input[type="range"] {
        min-width: 100px;
      }
    }
    
    /* Responsive labels */
    label {
      white-space: nowrap;
      font-size: 14px;
    }
    
    @media (max-width: 768px) {
      label {
        font-size: 13px;
      }
    }
    
    @media (max-width: 480px) {
      label {
        font-size: 12px;
      }
    }
    
    /* Responsive spans for slider values */
    span {
      font-size: 14px;
      min-width: 30px;
      text-align: center;
    }
    
    @media (max-width: 768px) {
      span {
        font-size: 13px;
        min-width: 25px;
      }
    }
    
    @media (max-width: 480px) {
      span {
        font-size: 12px;
        min-width: 20px;
      }
    }
    
    /* Responsive download link */
    #downloadLink {
      color: rgb(197, 201, 197);
      text-decoration: none;
      font-size: 14px;
      word-wrap: break-word;
      max-width: 100%;
      display: inline-block;
    }
    
    @media (max-width: 768px) {
      #downloadLink {
        font-size: 13px;
      }
    }
    
    @media (max-width: 480px) {
      #downloadLink {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <img src="./assets/clean logo.png" alt="Logo" class="header-logo" />
    <nav class="header-nav">
      <a href="index.html" class="nav-button">Home</a>
      <a href="Encoder.html" class="nav-button">Encoder</a>
      <a href="feed.html" class="nav-button">Feed</a>
      <a href="documentation.html" class="nav-button">Documentation</a>
    </nav>
  </header>

  <canvas id="matrixCanvas"></canvas>
  <img src="assets/incrypt title.png" alt="Incrypt" class="title-image">
  <div class="controls">
    <div class="file-input-container">
      <input type="file" id="portraitInput" accept="image/*" style="display: none;">
      <label for="portraitInput" class="file-input-label">Choose Image File</label>
    </div>
    <textarea id="textMessage" rows="4" cols="50" placeholder="Enter your secret message"></textarea>

    <!-- Add a simple toggle for Text/File mode -->
    <div style="margin: 1rem 0; display: flex; align-items: center; justify-content: center; gap: 1.5rem;">
      <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
        <input type="radio" name="modeType" id="textMode" checked> Text
      </label>
      <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
        <input type="radio" name="modeType" id="fileMode"> File
      </label>
    </div>
    <!-- File input for file message (hidden by default) -->
    <input type="file" id="fileInput" style="display:none; margin-bottom: 1rem;" />

    <!-- Remove advanced menu, add a simple toggle for pointillist mode above the action buttons -->
    <div style="margin: 1rem 0; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
      <input type="checkbox" id="modeToggle">
      <label for="modeToggle" style="color: #ccc; font-size: 1rem; cursor: pointer;">Use pointillist mode</label>
    </div>
    
    <!-- Encoding mode selection -->
    <div style="margin: 1rem 0; display: flex; align-items: center; justify-content: center; gap: 1rem;">
      <input type="radio" id="localEncode" name="encodeMode" value="local" checked>
      <label for="localEncode" style="color: #ccc; font-size: 1rem; cursor: pointer;">Local Encoding</label>
      <input type="radio" id="apiEncode" name="encodeMode" value="api">
      <label for="apiEncode" style="color: #ccc; font-size: 1rem; cursor: pointer;">External API</label>
    </div>
    
    <!-- Info about external encoding -->
    <div id="apiInfo" style="margin: 1rem 0; padding: 0.5rem; background: rgba(255, 255, 255, 0.1); border-radius: 5px; font-size: 0.9rem; color: #aaa; display: none;">
      <strong>Note:</strong> Encoding is processed by the external service at <a href="https://incryptor-exo.vercel.app/" target="_blank" style="color: #4CAF50;">incryptor-exo.vercel.app</a>
    </div>

    <div class="action-buttons">
      <button class="action-button" onclick="encode()" id="encodeButton">Encode</button>
      <button class="action-button" onclick="decode()">Decode</button>
      <button class="action-button" onclick="openExternalApp()" style="background: linear-gradient(45deg, #4CAF50, #45a049);">APP</button>
    </div>
    <div id="outputBox" class="output-box"></div>
    <a id="downloadLink" style="color: rgb(188, 188, 188);"></a>
    
    <!-- Share Section -->
    <div id="shareSection" class="share-section">
      <h4 style="margin-top: 0; margin-bottom: 15px; color: rgb(188, 188, 188);">Share Your Encoded Image</h4>
      <textarea 
        id="shareDescription" 
        class="share-description" 
        placeholder="Describe your encoded image or share a hint about the hidden message..."
      ></textarea>
      <button id="shareButton" class="action-button" onclick="shareToFeed()" disabled>
        Share to Feed
      </button>
    </div>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    // Add toggle function for advanced menu
    function toggleAdvanced() {
      const menu = document.getElementById('advancedMenu');
      menu.classList.toggle('show');
    }
  
    // Matrix background animation
    const matrixCanvas = document.getElementById('matrixCanvas');
    const matrixCtx = matrixCanvas.getContext('2d');
  
    matrixCanvas.width = window.innerWidth;
    matrixCanvas.height = window.innerHeight;
  
    const fontSize = 16;
    const columns = Math.floor(matrixCanvas.width / fontSize);
    const drops = Array(columns).fill(1);
  
    const characters = 'アカサタナハマヤラワガザダバパABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');
  
    let frameCounter = 0;
    const updateRate = 4;
  
    function drawMatrix() {
      if (frameCounter % updateRate !== 0) {
        requestAnimationFrame(drawMatrix);
        frameCounter++;
        return;
      }
  
      matrixCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
      matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
  
      matrixCtx.font = `${fontSize}px monospace`;
  
      for (let i = 0; i < columns; i++) {
        const char = characters[Math.floor(Math.random() * characters.length)];
        const flicker = Math.random() < 0.003;
  
        if (flicker) {
          matrixCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          matrixCtx.shadowBlur = 4;
          matrixCtx.shadowColor = '#ffffff';
        } else {
          matrixCtx.fillStyle = 'rgba(200, 200, 200, 0.15)';
          matrixCtx.shadowBlur = 0;
        }
  
        matrixCtx.fillText(char, i * fontSize, drops[i] * fontSize);
  
        if (drops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        drops[i]++;
      }
  
      frameCounter++;
      requestAnimationFrame(drawMatrix);
    }
  
    drawMatrix();
  
    window.addEventListener('resize', () => {
      matrixCanvas.width = window.innerWidth;
      matrixCanvas.height = window.innerHeight;
    });
  
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let uploadedImage = null;
  
    // Function to resize canvas to fit uploaded image
    function resizeCanvasToImage(image) {
      // Calculate maximum dimensions while maintaining aspect ratio
      const maxWidth = Math.min(16000, window.innerWidth - 100);
      const maxHeight = Math.min(16000, window.innerHeight - 200);
      
      let newWidth = image.width;
      let newHeight = image.height;
      
      // Scale down if image is too large
      if (newWidth > maxWidth || newHeight > maxHeight) {
        const scale = Math.min(maxWidth / newWidth, maxHeight / newHeight);
        newWidth = Math.floor(newWidth * scale);
        newHeight = Math.floor(newHeight * scale);
      }
      
      // Set canvas dimensions
      canvas.width = newWidth;
      canvas.height = newHeight;
      
      // Update canvas CSS for responsive display
      canvas.style.maxWidth = '100%';
      canvas.style.height = 'auto';
    }
  
    // Handle encoding mode switching
    const localEncode = document.getElementById("localEncode");
    const apiEncode = document.getElementById("apiEncode");
    const apiInfo = document.getElementById("apiInfo");
    const encodeButton = document.getElementById("encodeButton");

    function updateEncodeMode() {
      if (apiEncode.checked) {
        encodeButton.innerText = "Encode via API";
        apiInfo.style.display = "block";
      } else {
        encodeButton.innerText = "Encode";
        apiInfo.style.display = "none";
      }
    }

    localEncode.addEventListener('change', updateEncodeMode);
    apiEncode.addEventListener('change', updateEncodeMode);
    updateEncodeMode(); // Set initial state

    // Only keep modeToggle and its onchange handler
    const modeToggle = document.getElementById("modeToggle");
    modeToggle.onchange = function() {
      if (uploadedImage) {
        generateCanvas(uploadedImage);
      }
    };
  
    document.getElementById("portraitInput").addEventListener("change", e => {
      console.log("File input change event triggered");
      const file = e.target.files[0];
      if (!file) {
        console.log("No file selected");
        return;
      }
      console.log("File selected:", file.name, file.type, file.size);
      
      // Check if it's an image file
      if (!file.type.startsWith('image/')) {
        alert('Please select an image file (JPEG, PNG, GIF, etc.)');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = ev => {
        console.log("File read successfully");
        const img = new Image();
        img.onload = () => {
          console.log("Image loaded:", img.width, "x", img.height);
          uploadedImage = img;
          resizeCanvasToImage(img);
          generateCanvas(img);
        };
        img.onerror = () => {
          console.error("Error loading image");
          alert('Error loading image. Please try a different file.');
        };
        img.src = ev.target.result;
      };
      reader.onerror = () => {
        console.error("Error reading file");
        alert('Error reading file. Please try again.');
      };
      reader.readAsDataURL(file);
    });
  
    function generateCanvas(image) {
      const usePointillist = document.getElementById("modeToggle").checked;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
  
      if (!usePointillist) {
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        return;
      }
  
      // Draw the original image as the background
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      // Darken the background image
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalAlpha = 1.0;
  
      // Fixed settings for pointillist mode
      const dots = 150000;
      const jitter = 6;
  
      const temp = document.createElement('canvas');
      temp.width = image.width;
      temp.height = image.height;
      const tCtx = temp.getContext('2d');
      tCtx.drawImage(image, 0, 0);
      const imgData = tCtx.getImageData(0, 0, image.width, image.height).data;
  
      for (let i = 0; i < dots; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const srcX = Math.floor((x / canvas.width) * image.width);
        const srcY = Math.floor((y / canvas.height) * image.height);
        const idx = (srcY * image.width + srcX) * 4;
  
        let r = imgData[idx];
        let g = imgData[idx + 1];
        let b = imgData[idx + 2];
  
        r = Math.min(255, Math.max(0, r + (Math.random() * jitter - jitter / 2)));
        g = Math.min(255, Math.max(0, g + (Math.random() * jitter - jitter / 2)));
        b = Math.min(255, Math.max(0, b + (Math.random() * jitter - jitter / 2)));
  
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.beginPath();
        ctx.arc(x, y, 1, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  
    // Toggle between text and file input
    const textMode = document.getElementById('textMode');
    const fileMode = document.getElementById('fileMode');
    const textMessage = document.getElementById('textMessage');
    const fileInput = document.getElementById('fileInput');
    textMode.onchange = function() {
      if (textMode.checked) {
        textMessage.style.display = '';
        fileInput.style.display = 'none';
      }
    };
    fileMode.onchange = function() {
      if (fileMode.checked) {
        textMessage.style.display = 'none';
        fileInput.style.display = '';
      }
    };
    // Default to text mode
    textMessage.style.display = '';
    fileInput.style.display = 'none';
  
    // Helper for large file base64 encoding
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const chunkSize = 0x8000; // 32KB
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }
  
    let maxFileSize = 0;

    function calculateMaxFileSize() {
      if (!uploadedImage) return 0;
      // Get image data length
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      // For file mode: 8 bits per channel, minus 8 bytes for header, minus 2 bytes for length
      // Each channel is a byte, so (data.length - 8) / 8 - 2
      const availableBytes = Math.floor((data.length - 8) / 8) - 2;
      // Base64 expands data by ~4/3, so max file size is availableBytes * 3 / 4 (rounded down)
      return Math.floor(availableBytes * 3 / 4);
    }

    function updateMaxFileSizeDisplay() {
      const fileSizeInfo = document.getElementById('fileSizeInfo');
      if (!fileSizeInfo) return;
      if (!uploadedImage) {
        fileSizeInfo.innerText = '';
        return;
      }
      maxFileSize = calculateMaxFileSize();
      fileSizeInfo.innerText = `Max file size for this image: ${maxFileSize.toLocaleString()} bytes (${(maxFileSize/1024/1024).toFixed(2)} MB)`;
    }

    // Add file size info display to the UI
    const fileInputLabel = document.querySelector('label[for="fileInput"]');
    if (fileInputLabel) {
      const info = document.createElement('div');
      info.id = 'fileSizeInfo';
      info.style.color = '#aaa';
      info.style.fontSize = '0.95em';
      info.style.marginTop = '-0.5em';
      info.style.marginBottom = '1em';
      fileInputLabel.parentNode.insertBefore(info, fileInputLabel.nextSibling);
    }

    // Update max file size display when image is loaded or file mode is toggled
    function onImageOrModeChange() {
      updateMaxFileSizeDisplay();
    }

    // Call update on image load
    const origPortraitInputHandler = document.getElementById("portraitInput").onchange;
    document.getElementById("portraitInput").addEventListener("change", function(e) {
      setTimeout(onImageOrModeChange, 100); // Wait for image to load
    });
    fileMode.addEventListener('change', onImageOrModeChange);
    textMode.addEventListener('change', onImageOrModeChange);
  
    async function encode() {
      if (!uploadedImage) {
        alert('Please select a cover image first.');
        return;
      }

      let message = '';
      let bitDepth = 1;
      
      if (fileMode.checked) {
        const file = fileInput.files[0];
        if (!file) {
          alert('Please select a file to encode.');
          return;
        }
        // Check file size before encoding
        maxFileSize = calculateMaxFileSize();
        if (file.size > maxFileSize) {
          alert(`File is too large for this image!\nMax allowed: ${maxFileSize.toLocaleString()} bytes (${(maxFileSize/1024/1024).toFixed(2)} MB)\nSelected file: ${file.size.toLocaleString()} bytes (${(file.size/1024/1024).toFixed(2)} MB)`);
          return;
        }
        const arrayBuffer = await file.arrayBuffer();
        const base64 = arrayBufferToBase64(arrayBuffer);
        message = `FILE:${file.name}:${base64}`;
        bitDepth = 8;
      } else {
        message = textMessage.value;
        if (!message.trim()) {
          alert('Please enter a message to encode.');
          return;
        }
        bitDepth = 1;
      }

      // Check which encoding mode is selected
      const useApi = document.getElementById("apiEncode").checked;

      if (useApi) {
        await encodeViaAPI(message, bitDepth);
      } else {
        await encodeLocally(message, bitDepth);
      }
    }

    async function encodeViaAPI(message, bitDepth) {
      // Show loading state
      const encodeButton = document.getElementById("encodeButton");
      const originalText = encodeButton.innerText;
      encodeButton.innerText = "Encoding via API...";
      encodeButton.disabled = true;

      try {
        // Prepare the data for the external API
        const coverImageData = canvas.toDataURL('image/png');
        const usePointillist = document.getElementById("modeToggle").checked;
        
        // Create FormData for the API request
        const formData = new FormData();
        formData.append('coverImage', dataURLtoBlob(coverImageData), 'cover.png');
        formData.append('message', message);
        formData.append('bitDepth', bitDepth.toString());
        formData.append('pointillist', usePointillist.toString());

        // Send request to external API
        const response = await fetch('https://incryptor-exo.vercel.app/api/encode', {
          method: 'POST',
          body: formData,
          mode: 'cors',
          headers: {
            'Accept': 'application/json'
          }
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
        }

        const result = await response.json();
        
        if (result.success) {
          // Create a new image from the encoded data
          const encodedImage = new Image();
          encodedImage.onload = () => {
            uploadedImage = encodedImage;
            resizeCanvasToImage(encodedImage);
            generateCanvas(encodedImage);
            
            // Update download link
            const link = document.getElementById("downloadLink");
            link.href = canvas.toDataURL();
            link.download = "stego_image.png";
            link.innerText = "Download Image";
            
            // Show share section after successful encoding
            const shareSection = document.getElementById("shareSection");
            shareSection.classList.add("show");
            
            // Enable share button if description is provided
            const shareDescription = document.getElementById("shareDescription");
            const shareButton = document.getElementById("shareButton");
            shareDescription.addEventListener("input", function() {
              shareButton.disabled = !shareDescription.value.trim();
            });
            
            alert('Image encoded successfully via API!');
          };
          encodedImage.src = result.encodedImage;
        } else {
          throw new Error(result.error || 'Encoding failed');
        }
      } catch (error) {
        console.error('Error encoding image via API:', error);
        alert('Failed to encode image via API. Please check your internet connection and try again. Error: ' + error.message);
      } finally {
        // Reset button state
        encodeButton.innerText = originalText;
        encodeButton.disabled = false;
      }
    }

    async function encodeLocally(message, bitDepth) {
      // Show loading state
      const encodeButton = document.getElementById("encodeButton");
      const originalText = encodeButton.innerText;
      encodeButton.innerText = "Encoding...";
      encodeButton.disabled = true;

      try {
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        
        // Always set the first 8 pixels' LSBs to 0 before writing the header
        for (let i = 0; i < 8; i++) {
          data[i] = data[i] & ~1;
        }
        
        // Write 1-byte header: 0 = normal, 1 = pointillist
        const usePointillist = document.getElementById("modeToggle").checked ? 1 : 0;
        const headerBits = [];
        for (let i = 7; i >= 0; i--) headerBits.push((usePointillist >> i) & 1);
        for (let i = 0; i < 8; i++) {
          data[i] = (data[i] & ~1) | headerBits[i];
        }
        
        const messageBytes = new TextEncoder().encode(message);
        const length = messageBytes.length;
        // Store length as 2 bytes
        const msgHeader = new Uint8Array([length >> 8, length & 0xff]);
        const combined = new Uint8Array([...msgHeader, ...messageBytes]);
        let bitsArray = [];
        for (let byte of combined) {
          for (let i = 7; i >= 0; i--) bitsArray.push((byte >> i) & 1);
        }
        // Embed message as continuous bit stream, bitDepth bits per channel, starting after header
        let bitIdx = 0;
        for (let i = 8; i < data.length && bitIdx < bitsArray.length; i++) {
          for (let b = 0; b < bitDepth && bitIdx < bitsArray.length; b++) {
            data[i] = (data[i] & ~(1 << b)) | (bitsArray[bitIdx++] << b);
          }
        }
        
        ctx.putImageData(imgData, 0, 0);
        
        // Update download link
        const link = document.getElementById("downloadLink");
        link.href = canvas.toDataURL();
        link.download = "stego_image.png";
        link.innerText = "Download Image";
        
        // Show share section after successful encoding
        const shareSection = document.getElementById("shareSection");
        shareSection.classList.add("show");
        
        // Enable share button if description is provided
        const shareDescription = document.getElementById("shareDescription");
        const shareButton = document.getElementById("shareButton");
        shareDescription.addEventListener("input", function() {
          shareButton.disabled = !shareDescription.value.trim();
        });
        
        alert('Image encoded successfully locally!');
      } catch (error) {
        console.error('Error encoding image locally:', error);
        alert('Failed to encode image locally. Error: ' + error.message);
      } finally {
        // Reset button state
        encodeButton.innerText = originalText;
        encodeButton.disabled = false;
      }
    }

    // Helper function to convert data URL to blob
    function dataURLtoBlob(dataURL) {
      const arr = dataURL.split(',');
      const mime = arr[0].match(/:(.*?);/)[1];
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      return new Blob([u8arr], { type: mime });
    }

    // Function to open the external app
    function openExternalApp() {
      window.open('https://incryptor-exo.vercel.app/', '_blank');
    }
  
    async function shareToFeed() {
      const description = document.getElementById("shareDescription").value.trim();
      if (!description) return;
      
      // Get the encoded image data
      const imageData = canvas.toDataURL();
      
      // Show loading state
      const shareButton = document.getElementById("shareButton");
      const originalText = shareButton.innerText;
      shareButton.innerText = "Sharing...";
      shareButton.disabled = true;
      
      try {
        // Send post to API
        const response = await fetch('/api/posts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            image: imageData,
            description: description
          })
        });
        
        if (response.ok) {
          const newPost = await response.json();
          alert('Your encoded image has been shared to the public feed!');
          
          // Clear the description
          document.getElementById("shareDescription").value = '';
        } else {
          const error = await response.json();
          alert('Failed to share: ' + (error.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Error sharing post:', error);
        alert('Failed to share. Please check your internet connection and try again.');
      } finally {
        // Reset button state
        shareButton.innerText = originalText;
        shareButton.disabled = false;
      }
    }
  
    function decode() {
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      // Read 1-byte header from first 8 LSBs
      let modeBits = [];
      for (let i = 0; i < 8; i++) modeBits.push(data[i] & 1);
      let mode = 0;
      for (let i = 0; i < 8; i++) mode |= modeBits[i] << (7 - i);
      const usePointillist = mode === 1;
      const outputBox = document.getElementById('outputBox');
      // Try to decode as file (8 bits per channel, read bytes directly)
      let bytes8 = [];
      for (let i = 8; i < data.length; i++) {
        bytes8.push(data[i]);
      }
      // Read 2-byte length prefix
      const msgLength8 = (bytes8[0] << 8) | bytes8[1];
      const messageBytes8 = bytes8.slice(2, 2 + msgLength8);
      const msg8 = new TextDecoder().decode(new Uint8Array(messageBytes8));
      if (msg8.startsWith('FILE:')) {
        // File detected, show download link
        const firstColon = msg8.indexOf(':', 5);
        const filename = msg8.substring(5, firstColon);
        const base64 = msg8.substring(firstColon + 1);
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const blob = new Blob([bytes]);
        const url = URL.createObjectURL(blob);
        outputBox.innerHTML = `<b>Decoded file:</b> <a href="${url}" download="${filename}">Download ${filename}</a>`;
      } else {
        // Not a file, decode as text (1 bit per channel)
        let bits1 = [];
        for (let i = 8; i < data.length; i++) {
          bits1.push(data[i] & 1);
        }
        const lengthBits1 = bits1.slice(0, 16);
        const msgLength1 = (lengthBits1.slice(0, 8).reduce((acc, bit, i) => acc | (bit << (7 - i)), 0) << 8) |
                          lengthBits1.slice(8, 16).reduce((acc, bit, i) => acc | (bit << (7 - i)), 0);
        const messageBits1 = bits1.slice(16, 16 + msgLength1 * 8);
        const messageBytes1 = [];
        for (let i = 0; i < messageBits1.length; i += 8) {
          const byte = messageBits1.slice(i, i + 8).reduce((acc, bit, j) => acc | (bit << (7 - j)), 0);
          messageBytes1.push(byte);
        }
        const msg1 = new TextDecoder().decode(new Uint8Array(messageBytes1));
        outputBox.innerHTML =
          `<b>Pointillist mode: ${usePointillist ? 'On' : 'Off'}</b><br>` +
          `<b>Message:</b><br>${msg1}`;
      }
      outputBox.classList.add('show');
    }
  </script>
  
</body>
</html>